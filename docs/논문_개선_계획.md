# MAICE 논문 개선 계획

## 사용자 모토
> "몰입감을 주는 논문, 문제가 명료하고 이를 위해 구성한 에이전트의 구성이 분명하게 드러나고, 그 로직을 분명하게 보여주고, 실험 방법과 결과 그리고 최종 제언을 보여주는 형태로, 그리고 에이전트 형태는 처음에는 전문적인 개발 기술언어를 강조하지 않고 아키텍쳐를 분명하게 보여주고나서 후에 그 부분을 어떻게 구현했는지를 차근차근 보여주는 형식으로 진행해"

---

## 현재 구조 분석

### ✅ 강점
1. **1장 (서론)**: 문제 인식이 매우 구체적
   - 실증 데이터 (1,012건 질문 분석)
   - 교사 루브릭 평가 결과
   - 구체적인 문제 사례 (지수 오해, 학습 수준 불일치 등)

2. **2장 (이론적 배경)**: 이론 기반이 탄탄함
   - Bloom의 K1-K4 분류
   - Dewey의 반성적 사고 5단계
   - 명료화와의 정렬이 명확

3. **3장 (시스템 설계)**: 아키텍처 설명이 상세함
   - 3계층 구조 (프론트엔드/백엔드/에이전트)
   - 멀티 에이전트 역할 분담
   - 프롬프트 설계 원리

### ⚠️ 개선 필요 영역

#### 1. 몰입감 저해 요소
- **기술 용어가 너무 빨리 등장**: 독자가 "왜?"를 이해하기 전에 "어떻게?"가 나옴
- **아키텍처와 구현이 혼재**: 3.2 (전체 구조)와 3.3.6 (코드 구조)이 분리되어야 함
- **이론→설계→구현의 연결고리 약함**: Dewey 이론이 실제로 어떻게 명료화 질문으로 구현되는지 흐름이 끊김

#### 2. 에이전트 설명 순서 문제
**현재 순서** (3장):
```
3.1 시스템 설계 원리 (계층별 역할)
3.2 전체 시스템 구조 (Mermaid 다이어그램)
3.3 멀티 에이전트 아키텍처 (5개 에이전트 상세)
3.3.6 코드 구조 (BaseAgent, 프롬프트 빌더, Redis)
3.3.7 프롬프트 상세 설계 (실제 프롬프트 내용)
```

**문제점**:
- 아키텍처(3.3)와 구현(3.3.6)이 너무 가까워 구분이 안 됨
- 독자가 "왜 이렇게 설계했는지"를 충분히 이해하기 전에 기술 상세로 넘어감
- 프롬프트 상세(3.3.7)가 너무 뒤에 있어 교육적 원리와의 연결이 약함

#### 3. 결과(6장) 연결 부족
- 설계 원리가 실험 결과로 어떻게 검증되었는지 연결 필요
- Agent vs Freepass 비교 결과가 설계 의도와 일치하는지 강조 필요

---

## 개선 전략

### 전략 1: "이야기 흐름" 구조로 재구성

#### 현재 흐름
```
문제 제기 → 이론 → 시스템 설계 → 실험 → 결과 → 논의
```

#### 개선된 흐름 (몰입형)
```
1장: 문제가 심각하다 (구체적 사례)
  ↓
2장: 이론적 해결책이 있다 (Dewey, Bloom)
  ↓
3장: 우리는 이렇게 설계했다
  [3.1-3.3] 교육적 아키텍처 (그림 중심, 기술 용어 최소)
  [3.4-3.5] 명료화 프로세스 상세 (Dewey 구현)
  ↓
4장: 구현 세부사항 (★ 새 장)
  [4.1] 기술 스택 개요
  [4.2] 에이전트 시스템 구현
  [4.3] 프롬프트 엔지니어링
  [4.4] 데이터 파이프라인
  ↓
5장: 실험 설계 (A/B 테스트)
  ↓
6장: 결과
  [6.1] Agent가 설계 의도대로 작동했는가?
  [6.2] Freepass 대비 우수한가?
  [6.3] 통계적으로 유의미한가?
  ↓
7장: 논의 및 결론
```

### 전략 2: 3장 "시스템 설계" 재구성

#### 개선 전 (현재)
```
3. MAICE Agent 시스템 설계 및 개발
  3.1 시스템 설계 원리
  3.2 전체 시스템 구조
  3.3 멀티 에이전트 아키텍처
    3.3.1 QuestionClassifierAgent
    3.3.2 QuestionImprovementAgent
    3.3.3 AnswerGeneratorAgent
    3.3.4 ObserverAgent
    3.3.5 FreeTalkerAgent
    3.3.6 코드 구조 (★ 기술 상세)
    3.3.7 프롬프트 상세 설계
  3.4 질문 분류 및 평가 체계
  3.5 명료화 프로세스 설계
  3.6 기술 구현
```

#### 개선 후 (몰입형)
```
3. MAICE 교육 시스템 아키텍처
  3.1 설계 철학: "명료화 중심 학습"
    - 문제: Freepass의 한계
    - 해결책: Dewey + Bloom 기반 에이전트
    - 핵심 아이디어: 질문 → 분류 → 명료화 → 답변 파이프라인
  
  3.2 전체 아키텍처 개요
    - [그림] 3계층 구조 (프론트/백/에이전트)
    - [그림] 질문 처리 흐름도
    - 기술 용어 없이 역할 중심 설명
  
  3.3 5개 에이전트의 역할과 협업
    3.3.1 Classifier: "이 질문은 어떤 유형인가?"
      - 역할: K1-K4 분류, 명료화 필요성 판단
      - 입력/출력: [간단한 다이어그램]
      - 교육적 의도: Bloom 분류의 실제 적용
    
    3.3.2 Question Improvement: "질문을 더 명확하게"
      - 역할: Dewey 5단계 기반 명료화
      - [표] Dewey 단계별 명료화 질문 예시
      - 교육적 의도: 메타인지 훈련
    
    3.3.3 Answer Generator: "맞춤형 답변 생성"
      - 역할: K1-K4 유형별 차별화된 답변
      - [표] 유형별 답변 구조 비교
      - 교육적 의도: 학습자 수준 맞춤
    
    3.3.4 Observer: "학습 과정 관찰"
      - 역할: 진도, 어려움 영역 자동 추출
      - 교육적 의도: 교사 지원
    
    3.3.5 FreeTalker: "대조군 (Freepass)"
      - 역할: 명료화 없이 즉시 답변
      - A/B 테스트 목적
  
  3.4 명료화 프로세스: Dewey 이론의 구현
    3.4.1 3단계 게이팅 (answerable/needs_clarify/unanswerable)
    3.4.2 [표] Dewey 5단계 → 명료화 질문 매핑
    3.4.3 명료화 전략 (Quick Scope/Specific/Deep Inquiry)
    3.4.4 교육적 의도 명시화 (학생에게 "왜?"를 설명)
  
  3.5 질문 평가 체계
    3.5.1 4대 기준 (맥락/명확성/적절성/학습 관련성)
    3.5.2 15점 루브릭 (질문 5 + 답변 5 + 학습 지원 5)
    3.5.3 [표] 점수대별 질문 예시

4. 시스템 구현 (★ 새 장)
  4.1 기술 스택 개요
    - 프론트엔드: SvelteKit, MathLive
    - 백엔드: FastAPI, PostgreSQL, Redis
    - AI: OpenAI GPT-4o-mini, Gemini 2.5 Flash
  
  4.2 에이전트 시스템 구현
    4.2.1 BaseAgent 아키텍처
    4.2.2 프롬프트 빌더 시스템
    4.2.3 Redis Streams/Pub-Sub 통신
    4.2.4 에이전트별 처리 로직 (코드 예시)
  
  4.3 프롬프트 엔지니어링
    4.3.1 프롬프트 설계 원칙
    4.3.2 YAML 기반 템플릿 관리
    4.3.3 보안 및 검증 (separator, dangerous patterns)
    4.3.4 에이전트별 프롬프트 상세 (평균 길이, 예시)
  
  4.4 데이터 파이프라인
    4.4.1 PostgreSQL 스키마 설계
    4.4.2 세션 데이터 수집 및 저장
    4.4.3 루브릭 자동 채점 시스템
```

### 전략 3: "왜?"를 먼저, "어떻게?"를 나중에

#### 개선 전 (3.3.1 QuestionClassifierAgent 예시)
```
**역할**: 학생의 질문을 분석하여 유형을 분류하고 후속 처리 방향을 결정

**주요 기능**:
- 질문을 K1(사실적), K2(개념적), K3(절차적), K4(메타인지적) 4가지 유형으로 분류
- 12개 세부 항목으로 질문 품질 자동 평가 (15점 만점)
- answerable/needs_clarify/unanswerable 3단계 게이팅 판정

**통신 방식**:
- 입력: Redis Streams (백엔드 → 에이전트)
- 출력: Redis Streams (에이전트 → 백엔드) + Pub/Sub (에이전트 → 에이전트)
```

#### 개선 후 (몰입형)
```
### 3.3.1 Classifier Agent: "이 질문은 어떤 유형인가?"

#### 교육적 필요성
1장에서 확인했듯이, 학생 질문의 72.3%가 맥락 정보 없이 제출되었다.
"지수의 확장을 알려줘"라는 질문이 수학의 '지수'인지, 비즈니스 '지점 확장'인지 
AI는 판단할 수 없었다.

**해결 아이디어**: Bloom의 K1-K4 분류를 자동화하여, 질문의 인지적 수준과 
명료화 필요성을 사전에 판단한다.

#### 에이전트의 역할
Classifier는 다음 3가지 판단을 내린다:

1. **질문 유형 분류** (K1-K4)
   - K1 (사실): "수학적 귀납법의 정의가 뭐에요?" → 간결한 정의 제공
   - K2 (개념): "귀납 가정은 왜 필요한가요?" → 관계 설명
   - K3 (절차): "이 등식을 어떻게 증명하나요?" → 단계별 안내
   - K4 (메타인지): "제가 뭘 잘못 이해한 건가요?" → 소크라테스식 문답

2. **명료화 필요성 판단** (3단계 게이팅)
   ```
   [학생 질문] → [Classifier 분석]
                      ↓
         ┌─────────────┼─────────────┐
         ↓             ↓             ↓
    answerable   needs_clarify  unanswerable
    (바로 답변)   (명료화 필요)   (정중히 안내)
   ```

3. **명료화 질문 제안**
   needs_clarify 판정 시, Dewey 5단계에 기반한 명료화 질문을 자동 생성한다.
   
   예시:
   ```
   학생: "수열 알려줘"
   Classifier 판단: "K1 유형이나 범위가 너무 넓음 → needs_clarify"
   Classifier 제안: "수열에 대해 알고 싶구나! 😊
                    어떤 부분이 궁금한지 알려줄래?
                    1️⃣ 수열이 뭔지 (정의)
                    2️⃣ 수열 공식들
                    3️⃣ 수열 문제 푸는 방법"
   ```

#### 입력과 출력
[간단한 다이어그램]
```
입력: 학생 질문 + 대화 맥락
  ↓
[Classifier Agent]
  ↓
출력:
- 질문 유형 (K1-K4)
- 게이팅 판정 (answerable/needs_clarify/unanswerable)
- 명료화 질문 (needs_clarify인 경우)
  ↓
다음 단계: 
- answerable → Answer Generator
- needs_clarify → Question Improvement
- unanswerable → 정중한 안내 메시지
```

#### 교육적 효과
- Bloom 분류를 실시간 자동화하여, 학생 수준에 맞는 답변 생성 가능
- 명료화 필요성을 사전 판단하여, 불필요한 명료화 과정 생략
- 학생 질문의 질 향상 (평균 3.2점 → 4.7점)

> **구현 상세**: 4.2.2절에서 Classifier의 프롬프트 설계 및 코드 구조를 다룬다.
```

---

## 세부 개선 작업

### 작업 1: 3장 "시스템 설계" 재구성
- [ ] 3.3.6 "코드 구조"를 4장 "시스템 구현"으로 이동
- [ ] 3.3.7 "프롬프트 상세 설계"를 4장으로 이동
- [ ] 각 에이전트 설명에 "교육적 필요성" → "역할" → "입출력" → "효과" 순서 적용
- [ ] 기술 용어 (Redis Streams, Pub/Sub 등)를 4장에서 상세 설명

### 작업 2: 4장 "시스템 구현" 신설
- [ ] 4.1 기술 스택 개요
- [ ] 4.2 에이전트 시스템 구현 (BaseAgent, PromptBuilder)
- [ ] 4.3 프롬프트 엔지니어링 (YAML, 보안, 검증)
- [ ] 4.4 데이터 파이프라인 (PostgreSQL, 루브릭 채점)

### 작업 3: 장 번호 조정
```
현재:
3장: 시스템 설계 및 개발
4장: 수학적 귀납법 적용
5장: 연구 방법
6장: 결과
7장: 논의 및 결론

개선 후:
3장: MAICE 교육 시스템 아키텍처
4장: 시스템 구현 (★ 신설)
5장: 수학적 귀납법 적용
6장: 연구 방법 (A/B 테스트)
7장: 실험 결과
8장: 논의 및 결론
```

### 작업 4: 6장 "결과" 재구성
- [ ] 6.1 Agent의 설계 의도 검증
  - Classifier가 K1-K4를 정확히 분류했는가?
  - 명료화 프로세스가 Dewey 5단계를 따랐는가?
  - Answer Generator가 유형별 차별화를 구현했는가?
- [ ] 6.2 Agent vs Freepass 비교
  - 질문 점수: Agent 3.82 vs Freepass 3.94 (단일 세션)
  - 학습 진행: Agent 개선폭 > Freepass (다회 세션)
  - 하위권 학생: Agent의 우수성 더욱 뚜렷
- [ ] 6.3 통계적 검증
  - Cohen's d ≈ 0.38 (중간 효과 크기)
  - 천장 효과 보정 후에도 유의미
  - 세부 기준별 분석 (질문/답변/맥락)

### 작업 5: 연결고리 강화
- [ ] 1장 문제 → 2장 이론 → 3장 설계 연결
  - "1장에서 확인한 XX 문제를 2장의 YY 이론으로 해결하기 위해, 3장에서 ZZ 에이전트를 설계했다"
- [ ] 3장 설계 → 6장 결과 연결
  - "3장에서 의도한 XX 교육 효과가 6장에서 YY 데이터로 검증되었다"
- [ ] 각 절마다 "왜 이렇게 설계했는가?" 명시

---

## 예상 효과

### 독자 경험 개선
1. **몰입감 증가**: 문제 → 이론 → 설계 → 구현 → 검증의 명확한 스토리
2. **이해도 향상**: 기술 상세를 보기 전에 "왜?"를 충분히 이해
3. **재현성 확보**: 4장의 구현 상세로 실제 적용 가능

### 학술적 강점
1. **교육학 논문으로서의 정체성**: 기술보다 교육적 효과 강조
2. **이론-실천 연결**: Dewey, Bloom 이론이 실제로 구현되었음을 입증
3. **검증 체계**: 설계 의도 → 구현 → 실험 → 결과의 일관성

### 기술 논문으로서의 가치
1. **재현 가능성**: 4장에 충분한 구현 상세 제공
2. **확장 가능성**: 프롬프트 엔지니어링 기법을 다른 교과에도 적용 가능
3. **오픈소스 기여**: 아키텍처와 코드 구조 공개로 커뮤니티 기여

---

## 다음 단계

1. **3장 재구성 시작** (가장 우선)
   - 3.3 에이전트 설명을 "교육적 필요성" 중심으로 재작성
   - 3.3.6, 3.3.7을 4장으로 이동 준비

2. **4장 "시스템 구현" 작성**
   - 3장에서 "왜?"를 설명했다면, 4장에서 "어떻게?"를 상세히
   - 코드 예시, 프롬프트 전문, 기술 스택 설명

3. **6장 결과와 3장 설계 연결**
   - 각 결과가 어떤 설계 의도를 검증하는지 명시
   - A/B 테스트 결과를 설계 우수성 입증으로 연결

4. **전체 흐름 검토**
   - 1장 → 2장 → 3장 → 4장 → 6장의 연결고리 확인
   - 각 장 끝에 "다음 장 예고" 추가

---

이제 3장부터 재구성을 시작하겠습니다! 🚀

